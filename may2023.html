<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="may2023.css">
  <title>NJPLS May 2023</title>
</head>

<body>
  <div id="banner"></div>
  <div class="content">
    <div class="header">
      <h1 class="title">
        <span class="light">New Jersey</span><br />
        Programming Languages and Systems<br />
        <span class="light">Seminar</span>
      </h1>
      <div class="cta">
        <h2 class="date">May 19, 2023</h2>
        <h2 class="location">University of Pennsylvania</h2>
      </div>

      <p>
        The <a href="https://njpls.org">New Jersey Programming Languages and Systems Seminar
          (NJPLS)</a> brings researchers in the New Jersey area together for a day of informal talks
        and discussions. We accept talks on complete research and work in progress, dealing with
        topics of interest to the programming languages and systems communities. See the talk
        proposal form for more information.
      </p>

      <p>
        <strong>Registration is free thanks to <a href="https://www.janestreet.com/">Jane Street</a>!</strong>
      </p>

      <table class="details">
        <tr>
          <td><strong>When</strong></td>
          <td>Friday May 19, 2023</td>
        </tr>
        <tr>
          <td><strong>Where</strong></td>
          <td>Levine Hall &middot; <a href="https://goo.gl/maps/kzomboXEdNXfyTkt7">3330 Walnut Street Philadelphia, PA
              19104</a>
          </td>
        </tr>
        <tr>
          <td><strong>What</strong></td>
          <td>Research talks and discussions. Breakfast, lunch, and coffee provided.</td>
        </tr>
      </table>

      <p>
        Talk proposals are due <strong>April 21, 2023</strong>. Registration is free, and all
        attendees should register with the registration form by <strong>May 12, 2023</strong> (even
        if you have an accepted talk). Contact <a href="mailto:hgo@seas.upenn.edu">hgo@seas.upenn.edu</a> with questions
        or concerns.
      </p>

      <table class="schedule">
        <tr>
          <td>9:00 AM</td>
          <td>Breakfast</td>
        </tr>
        <tr>
          <td>10:00 AM</td>
          <td>TBD</td>
          <td align="right">Richard Eisenberg <em>Jane Street</em></td>
        </tr>
        <tr>
          <td colspan="3">
            <p>TBD</p>
          </td>
        </tr>
        <tr>
          <td>10:20 AM</td>
          <td>Intensional Functions</td>
          <td align="right">Zachary Palmer <em>Swarthmore College</em></td>
        </tr>
        <tr>
          <td colspan="3">
            <p>
              Functions in functional languages have a single eliminator — application — and cannot be compared,
              hashed, or subjected to other non-application operations. Such operations are usually approximated via
              defunctionalization: functions are replaced with first-order data and calls are replaced with invocations
              of
              a dispatch function. We can then subject these first-order data to e.g. approximate equality, allowing
              (among other operations) the deduplication of continuations in a long-running computation. Unfortunately,
              surface-level defunctionalization is a laborious, error-prone, and maintenance-inducing transformation.
            </p>
            <p>
              In this talk, we discuss ""intensional functions"": a language feature which provides an alternative to
              manual defunctionalization. Intensional functions support non-application operations such as equality or
              hashing in terms of the program point at which the function was defined and the values it captured in
              closure. We then discuss one implication of this language feature: as intensional functions are functions
              which can be compared, hashed, and so on, so ""intensional monads"" are composable units of computation
              which can be compared, hashed, and so on. We illustrate this discussion with a practical example: the
              legible definition of efficient deductive closures."
            </p>
          </td>
        </tr>
        <tr>
          <td>10:40 AM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>11:00 AM</td>
          <td>Coffee</td>
        </tr>
        <tr>
          <td>11:20 AM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>11:40 AM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>12:00 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>12:20 PM</td>
          <td>Lunch</td>
        </tr>
        <tr>
          <td>1:40 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>2:00 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>2:20 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>2:40 PM</td>
          <td>Coffee</td>
        </tr>
        <tr>
          <td>3:20 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>3:40 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>4:00 PM</td>
          <td>Talk</td>
        </tr>
        <tr>
          <td>4:20 PM</td>
          <td>Closing Remarks</td>
        </tr>
      </table>

      <div class="buttons">
        <a href="https://forms.gle/oVpJo7SXutsZUjND6">Register to Attend</a>
      </div>
    </div>
  </div>
</body>

</html>